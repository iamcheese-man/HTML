<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>JWT Toolbox</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #ffffff;
      --text: #111111;
      --input-bg: #f4f4f4;
      --input-border: #cccccc;
      --pre-bg: #eeeeee;
      --success: #007700;
      --danger: #cc0000;
    }

    body.dark {
      --bg: #121212;
      --text: #eeeeee;
      --input-bg: #222222;
      --input-border: #444444;
      --pre-bg: #1a1a1a;
      --success: #4caf50;
      --danger: #ff4c4c;
    }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: monospace;
      max-width: 800px;
      margin: auto;
      padding: 2rem;
      transition: background 0.3s, color 0.3s;
    }

    textarea, input, button {
      width: 100%;
      margin: 0.5rem 0;
      padding: 0.6rem;
      font-size: 1rem;
      background: var(--input-bg);
      color: var(--text);
      border: 1px solid var(--input-border);
      border-radius: 5px;
      transition: background 0.3s, color 0.3s;
      font-family: monospace;
    }

    button {
      background: #0066cc;
      color: white;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
    }

    button:hover {
      background: #004999;
    }

    pre {
      background: var(--pre-bg);
      padding: 1rem;
      border-radius: 5px;
      white-space: pre-wrap;
      word-break: break-word;
      font-family: monospace;
      margin-top: 0.5rem;
    }

    .section {
      border-bottom: 1px solid var(--input-border);
      padding-bottom: 1rem;
      margin-bottom: 1.5rem;
    }

    .danger {
      color: var(--danger);
      font-weight: bold;
    }

    .success {
      color: var(--success);
      font-weight: bold;
    }

    #themeToggle {
      float: right;
      margin-top: -1rem;
      margin-bottom: 1rem;
      cursor: pointer;
      font-size: 0.9rem;
      user-select: none;
    }
  </style>
</head>
<body class="dark">

<h1>
  JWT Tool
  <span id="themeToggle" title="Toggle light/dark theme">üåô Toggle Theme</span>
</h1>

<div class="section">
  <label>Paste JWT:</label>
  <textarea id="jwtInput" placeholder="Paste token here..."></textarea>
  <label>Verify with Secret or Public Key:</label>
  <textarea id="verifyKey" placeholder="HS256: secret OR RS256: public PEM"></textarea>
  <button onclick="decodeAndVerify()">Decode & Verify</button>
  <div id="decodeResult"></div>
</div>

<div class="section">
  <label>JWT Header (JSON):</label>
  <textarea id="jwtHeader">{ "alg": "HS256", "typ": "JWT" }</textarea>
  <label>JWT Payload (JSON):</label>
  <textarea id="jwtPayload">{ "sub": "123", "name": "Alice", "iat": 1516239022 }</textarea>
  <label>Sign with Secret or Private Key:</label>
  <textarea id="signKey" placeholder="HS256: secret (RS256 unsupported in browser)"></textarea>
  <button onclick="encodeJWT()">Encode</button>
  <div id="encodeResult"></div>
</div>

<div class="section">
  <button onclick="importFromClipboard()">üìã Paste from Clipboard</button>
  <button onclick="exportToClipboard()">üì§ Copy to Clipboard</button>
  <button onclick="importFromFile()">üìÇ Load Token from File</button>
  <input type="file" id="fileInput" style="display:none;" />
  <button onclick="generateFake()">üé≤ Generate Fake JWT</button>
</div>

<script>
  const jwtInput = document.getElementById("jwtInput");
  const verifyKey = document.getElementById("verifyKey");
  const jwtHeader = document.getElementById("jwtHeader");
  const jwtPayload = document.getElementById("jwtPayload");
  const signKey = document.getElementById("signKey");
  const encodeResult = document.getElementById("encodeResult");
  const decodeResult = document.getElementById("decodeResult");
  const themeToggle = document.getElementById("themeToggle");
  const fileInput = document.getElementById("fileInput");

  // Base64URL encode/decode helpers
  const base64Url = {
    encode: str => btoa(str).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, ""),
    decode: str => {
      str = str.replace(/-/g, "+").replace(/_/g, "/");
      while (str.length % 4) str += "=";
      return atob(str);
    }
  };

  function pretty(obj) {
    return JSON.stringify(obj, null, 2);
  }

  async function hmacSha256(key, data) {
    const enc = new TextEncoder();
    const cryptoKey = await crypto.subtle.importKey(
      "raw",
      enc.encode(key),
      { name: "HMAC", hash: "SHA-256" },
      false,
      ["sign"]
    );
    const sig = await crypto.subtle.sign("HMAC", cryptoKey, enc.encode(data));
    return base64Url.encode(String.fromCharCode(...new Uint8Array(sig)));
  }

  async function importPemKey(pem) {
    const clean = pem.replace(/-----(BEGIN|END)[\s\S]+?-----/g, "").replace(/\s+/g, "");
    const bin = Uint8Array.from(atob(clean), c => c.charCodeAt(0));
    return await crypto.subtle.importKey(
      "spki",
      bin.buffer,
      { name: "RSASSA-PKCS1-v1_5", hash: "SHA-256" },
      false,
      ["verify"]
    );
  }

  async function decodeAndVerify() {
    decodeResult.innerHTML = "";
    try {
      const [head64, payload64, sig] = jwtInput.value.trim().split(".");
      if (!head64 || !payload64 || !sig) throw new Error("Invalid JWT format");
      const header = JSON.parse(base64Url.decode(head64));
      const payload = JSON.parse(base64Url.decode(payload64));
      const unsigned = `${head64}.${payload64}`;
      let valid = false;

      if (header.alg === "HS256") {
        const expected = await hmacSha256(verifyKey.value, unsigned);
        valid = (expected === sig);
      } else if (header.alg === "RS256") {
        const pubKey = await importPemKey(verifyKey.value);
        const sigBuf = Uint8Array.from(atob(sig.replace(/-/g, '+').replace(/_/g, '/')), c => c.charCodeAt(0));
        valid = await crypto.subtle.verify(
          "RSASSA-PKCS1-v1_5",
          pubKey,
          sigBuf,
          new TextEncoder().encode(unsigned)
        );
      }

      const now = Math.floor(Date.now() / 1000);
      let expInfo = "‚è≥ No expiration";
      if (payload.exp) {
        const diff = payload.exp - now;
        if (diff > 0) {
          expInfo = `‚è∞ Expires in: ${diff} seconds`;
        } else {
          expInfo = `‚è∞ Expired ${-diff} seconds ago`;
        }
      }

      decodeResult.innerHTML = `
        <pre>Header:\n${pretty(header)}</pre>
        <pre>Payload:\n${pretty(payload)}</pre>
        <div class="${valid ? 'success' : 'danger'}">Signature ${valid ? "VALID ‚úÖ" : "INVALID ‚ùå"}</div>
        <div>${expInfo}</div>
      `;
    } catch (e) {
      decodeResult.innerHTML = `<div class="danger">Error: ${e.message}</div>`;
    }
  }

  async function encodeJWT() {
    encodeResult.innerHTML = "";
    try {
      const header = JSON.parse(jwtHeader.value);
      const payload = JSON.parse(jwtPayload.value);
      const head64 = base64Url.encode(JSON.stringify(header));
      const payload64 = base64Url.encode(JSON.stringify(payload));
      const unsigned = `${head64}.${payload64}`;
      let sig = "";

      if (header.alg === "HS256") {
        sig = await hmacSha256(signKey.value, unsigned);
      } else if (header.alg === "RS256") {
        encodeResult.innerHTML = `<div class="danger">RS256 encoding not supported in browser.</div>`;
        return;
      } else {
        encodeResult.innerHTML = `<div class="danger">Unsupported algorithm: ${header.alg}</div>`;
        return;
      }

      encodeResult.innerHTML = `<pre>${unsigned}.${sig}</pre>`;
    } catch (e) {
      encodeResult.innerHTML = `<div class="danger">Encoding failed: ${e.message}</div>`;
    }
  }

  function generateFake() {
    const fakeHeader = { alg: "HS256", typ: "JWT" };
    const fakePayload = { sub: "123", exp: Math.floor(Date.now() / 1000) + 60 };
    jwtInput.value =
      base64Url.encode(JSON.stringify(fakeHeader)) + "." +
      base64Url.encode(JSON.stringify(fakePayload)) + "." +
      "fakeSIG";
    decodeResult.innerHTML = `<div class="success">üé≤ Fake token generated!</div>`;
  }

  async function importFromClipboard() {
    try {
      const text = await navigator.clipboard.readText();
      jwtInput.value = text;
    } catch {
      alert("Failed to read from clipboard.");
    }
  }

  async function exportToClipboard() {
    try {
      const token = encodeResult.textContent.trim();
      if (!token) {
        alert("Nothing to copy!");
        return;
      }
      await navigator.clipboard.writeText(token);
      alert("Copied encoded token to clipboard.");
    } catch {
      alert("Failed to copy to clipboard.");
    }
  }

  function importFromFile() {
    fileInput.onchange = () => {
      if (fileInput.files.length === 0) return;
      const reader = new FileReader();
      reader.onload = () => jwtInput.value = reader.result;
      reader.readAsText(fileInput.files[0]);
    };
    fileInput.click();
  }

  // Theme toggle logic
  themeToggle.onclick = () => {
    if (document.body.classList.contains("dark")) {
      document.body.classList.remove("dark");
      document.body.classList.add("light");
      themeToggle.textContent = "‚òÄÔ∏è Toggle Theme";
    } else {
      document.body.classList.remove("light");
      document.body.classList.add("dark");
      themeToggle.textContent = "üåô Toggle Theme";
    }
  };

  // Default theme
  if (!document.body.classList.contains("dark") && !document.body.classList.contains("light")) {
    document.body.classList.add("dark");
  }
</script>

</body>
</html>
